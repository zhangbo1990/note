# Monitors(管程)

管程是一种程序设计方式，通过这种设计方式可以并发场景下访问和操作共享变量保证其线程安全。
管程提现了面向对象封装的思想
要求：

1. 同一时间只有一个线程进入管程代码区（通过互斥锁来实现），未进入的进程在等待队列阻塞
2. 进入管程代码后未满足所需条件变量进程，释放互斥锁（以便让其他线程改变条件），进入条件等待队列，等待条件改变满足是被唤醒
3. 进入管程如果满足条件，则执行代码，如果改变了某些条件变量，需要通知唤醒等待该条件满足的线程
4. 在条件满足后，当前线程（通知唤醒条件等待队列等待线程的线程）和 等待队列里的线程（被通知唤醒的线程）的执行顺序 衍生了三种模型
    - 一种是将通知动作放在通知线程最后，这样通知线程执行完了再通知等待队列里的线程
    - 第二种先通知条件等待队列里的线程，自己阻塞，等被通知的线程执行完成之后再唤醒自己（这样就增加里一次阻塞唤醒的动作）
    - 还有一种就是唤醒条件等待队列里的线程，但他们不会马上执行会进入管程外的等待队列，等待重新获得互斥锁进入管程执行，而当前线程会继续执行下去（这种方法存在的问题是当被唤醒线程再次获得互斥锁进入时，刚才满足的条件有可能又不满足了）java中都是采用最后这种机制
5. java 提供synchronized 可重入锁，条件变量都是实现管程的工具

//todo 代码实现阻塞队列
  参考文章 [管程：并发编程的万能钥匙] <https://time.geekbang.org/column/article/86089>
  [wiki]<https://zh.wikipedia.org/wiki/%E7%9B%A3%E8%A6%96%E5%99%A8_(%E7%A8%8B%E5%BA%8F%E5%90%8C%E6%AD%A5%E5%8C%96)>